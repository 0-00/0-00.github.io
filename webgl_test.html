<html>
  <head>
    <script id="vertex" type="x-shader">
      attribute vec2 coordinates;

      void main() {
          gl_Position = vec4(coordinates, 0.0, 1.0);
      }
    </script>
    <script id="fragment" type="x-shader">
      #ifdef GL_ES
      precision highp float;
      #endif

      void main() {
          gl_FragColor = vec4(1.0,1.0,1.0,1.0);
      }
    </script>
    <script type="text/javascript">
      window.onload = function () {
        /*============ Creating a canvas =================*/

        let cursorX = 0;
        let cursorY = 0;
        let boxX = 16;
        let boxY = 16;
        var fontsheetX = 16;
        var fontsheetY = 16;
        var fontsizeX = 10;
        var fontsizeY = 10;
        var consoleX = 72;
        var consoleY = 40;

        var scale = 1.0;
        canvas = document.getElementById("myCanvas");
        gl =
          canvas.getContext("webgl", { antialias: false }) ||
          canvas.getContext("experimental-webgl", { antialias: false });

        scaleX = document.body.clientWidth / (consoleX * fontsizeX);
        scaleY = document.body.clientHeight / (consoleY * fontsizeY);

        scale = scaleY; //X > scaleY ? scaleX : scaleY;

        canvas.width = consoleX * fontsizeX * scale;
        canvas.height = consoleY * fontsizeY * scale;

        /*====================== Init Shaders =======================*/

        var v = document.getElementById("vertex").firstChild.nodeValue;
        var f = document.getElementById("fragment").firstChild.nodeValue;

        var vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, v);
        gl.compileShader(vs);

        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, f);
        gl.compileShader(fs);

        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        /*========== Defining and storing the geometry =========*/

        // var aspect = canvas.width / canvas.height;

        // var pixel_unit = 1 / (consoleY * fontsizeX);
        // var square_verts = new Float32Array([
        //   -pixel_unit / aspect,
        //   -pixel_unit,
        //   pixel_unit / aspect,
        //   -pixel_unit,
        //   -pixel_unit / aspect,
        //   pixel_unit,
        //   pixel_unit / aspect,
        //   pixel_unit,
        // ]);

        // var square_indices = [0, 1, 2, 2, 1, 3];

        var x_sqs = fontsizeX * consoleX;
        var y_sqs = fontsizeY * consoleY;

        // var x_sqs = 300;
        // var y_sqs = x_sqs;

        grid_vertices_data = [];
        indices = [];

        for (var y = y_sqs; y >= 0; y--) {
          for (var x = 0; x <= x_sqs; x++) {
            grid_vertices_data.push((2 * x) / x_sqs - 1, (2 * y) / y_sqs - 1);
          }
        }

        grid_vertices_array = new Float32Array(grid_vertices_data);

        console.log("vertex count:", grid_vertices_data.length);

        const render_pixel = (x, y) => {
          var bot_left = x + y * (x_sqs + 1);
          var bot_right = bot_left + 1;
          var top_left = bot_left + (x_sqs + 1);
          var top_right = top_left + 1;

          indices.push(
            bot_left,
            top_left,
            bot_right,
            bot_right,
            top_left,
            top_right
          );
        };

        function log_quad_vertices() {
          var quads = indices.length / 6;
          console.log("indices", indices);
          console.log("quad count:", quads);
          for (var i = 0; i < quads; i++) {
            quad = indices.slice(i * 6, i * 6 + 6);
            // console.log("");
            // console.log("slice:", quad);
            // console.log(
            //   "top left",
            //   quad[1],
            //   "(",
            //   grid_vertices_data[quad[1] * 2],
            //   grid_vertices_data[quad[1] * 2 + 1],
            //   " )"
            // );
            // console.log(
            //   "top right",
            //   quad[5],
            //   "(",
            //   grid_vertices_data[quad[5] * 2],
            //   grid_vertices_data[quad[5] * 2 + 1],
            //   " )"
            // );
            // console.log(
            //   "bottom left",
            //   quad[0],
            //   "(",
            //   grid_vertices_data[quad[0] * 2],
            //   grid_vertices_data[quad[0] * 2 + 1],
            //   " )"
            // );
            // console.log(
            //   "bottom right",
            //   quad[2],
            //   "(",
            //   grid_vertices_data[quad[2] * 2],
            //   grid_vertices_data[quad[2] * 2 + 1],
            //   " )"
            // );
          }
          console.log();
        }

        for (var i = 0; i < x_sqs; i++) {
          render_pixel(i, i);
        }
        log_quad_vertices();

        vbuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);

        gl.bufferData(gl.ARRAY_BUFFER, grid_vertices_array, gl.STATIC_DRAW);

        var Index_Buffer = gl.createBuffer();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        /* ======= Associating shaders to buffer objects =======*/

        gl.useProgram(program);

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);

        // Bind index buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Get the attribute location
        var coord = gl.getAttribLocation(program, "coordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coord);

        /*============= Drawing the Quad ================*/

        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      };
    </script>
    <style>
      body {
        background-color: green;
      }

      canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        margin-right: -50%;
        transform: translate(-50%, -50%);
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
  </body>
</html>
