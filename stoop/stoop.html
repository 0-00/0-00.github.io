<html>
  <head>
    <title>STÖÖP (Stack-based lööpy language)</title>
    <script type="text/javascript" src="cp437.js"></script>
    <script id="vertex" type="x-shader">
      attribute vec2 coordinates;
      attribute vec2 offset;

      void main() {
          gl_Position = vec4(coordinates+offset, 0.0, 1.0);
      }
    </script>
    <script id="fragment" type="x-shader">
      #ifdef GL_ES
      precision highp float;
      #endif

      void main() {
          gl_FragColor = vec4(1.0,1.0,1.0,1.0);
      }
    </script>
    <script type="text/javascript">
      let cursorX = 0;
      let cursorY = 0;
      let boxX = 16;
      let boxY = 16;
      var fontsheetX = 16;
      var fontsheetY = 16;
      var fontsizeX = 10;
      var fontsizeY = 10;
      var consoleX = 72;
      var consoleY = 40;
      var scale = 1.5;

      let ctrl = false;
      let shift = false;
      let run = false;

      let output = "";

      const state = {
        EDIT: "edit",
        RUN: "run",
      };

      const dir = {
        UP: 0,
        DOWN: 1,
        LEFT: 2,
        RIGHT: 3,
      };

      const token = {
        UP: {
          ascii: 24,
          action: function () {
            direction = tok;
          },
          isKeyPressed: function (shift_pressed, key) {
            return e.key == "ArrowUp" && shift_pressed;
          },
        },
        DOWN: {
          ascii: 25,
          action: function () {
            direction = tok;
          },
          isKeyPressed: function (shift_pressed, key) {
            return e.key == "ArrowDown" && shift_pressed;
          },
        },
        LEFT: {
          ascii: 27,
          action: function () {
            direction = tok;
          },
          isKeyPressed: function (shift_pressed, key) {
            return e.key == "ArrowLeft" && shift_pressed;
          },
        },
        RIGHT: {
          ascii: 26,
          action: function () {
            direction = tok;
          },
          isKeyPressed: function (shift_pressed, key) {
            return e.key == "ArrowRight" && shift_pressed;
          },
        },
        EMPTY: {
          ascii: " ".charCodeAt(0),
          action: function () {},
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        ZERO: {
          ascii: "0".charCodeAt(0),
          action: function () {
            stack.push(0);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        ONE: {
          ascii: "1".charCodeAt(0),
          action: function () {
            stack.push(1);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        TWO: {
          ascii: "2".charCodeAt(0),
          action: function () {
            stack.push(2);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        THREE: {
          ascii: "3".charCodeAt(0),
          action: function () {
            stack.push(3);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        FOUR: {
          ascii: "4".charCodeAt(0),
          action: function () {
            stack.push(4);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        FIVE: {
          ascii: "5".charCodeAt(0),
          action: function () {
            stack.push(5);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        SIX: {
          ascii: "6".charCodeAt(0),
          action: function () {
            stack.push(6);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        SEVEN: {
          ascii: "7".charCodeAt(0),
          action: function () {
            stack.push(7);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        EIGHT: {
          ascii: "8".charCodeAt(0),
          action: function () {
            stack.push(8);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        NINE: {
          ascii: "9".charCodeAt(0),
          action: function () {
            stack.push(9);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        A: {
          ascii: "A".charCodeAt(0),
          action: function () {
            stack.push(10);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        B: {
          ascii: "B".charCodeAt(0),
          action: function () {
            stack.push(11);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        C: {
          ascii: "C".charCodeAt(0),
          action: function () {
            stack.push(12);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        D: {
          ascii: "D".charCodeAt(0),
          action: function () {
            stack.push(13);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        E: {
          ascii: "E".charCodeAt(0),
          action: function () {
            stack.push(14);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        F: {
          ascii: "F".charCodeAt(0),
          action: function () {
            stack.push(15);
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        ADD: {
          ascii: "+".charCodeAt(0),
          action: function () {
            if (stack.length > 1) {
              a = stack.pop();
              b = stack.pop();
              stack.push(b + a);
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        SUB: {
          ascii: "-".charCodeAt(0),
          action: function () {
            if (stack.length > 1) {
              a = stack.pop();
              b = stack.pop();
              stack.push(b - a);
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        MUL: {
          ascii: "*".charCodeAt(0),
          action: function () {
            if (stack.length > 1) {
              a = stack.pop();
              b = stack.pop();
              stack.push(b * a);
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        DIV: {
          ascii: "/".charCodeAt(0),
          action: function () {
            if (stack.length > 1) {
              a = stack.pop();
              b = stack.pop();
              stack.push(Math.floor(b / a));
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        MOD: {
          ascii: "%".charCodeAt(0),
          action: function () {
            if (stack.length > 1) {
              a = stack.pop();
              b = stack.pop();
              stack.push(b % a);
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        EMPTY_STACK: {
          ascii: "_".charCodeAt(0),
          action: function () {
            if (stack.length == 0) {
              rotateClockwise();
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        ZERO_TEST: {
          ascii: "?".charCodeAt(0),
          action: function () {
            if (stack[stack.length - 1] == 0) {
              rotateClockwise();
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        CLONE_TOP: {
          ascii: 127,
          action: function () {
            if (stack.length > 0) {
              stack.push(stack[stack.length - 1]);
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        POP: {
          ascii: "^".charCodeAt(0),
          action: function () {
            stack.pop();
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },
        PRINT_CHAR: {
          ascii: "p".charCodeAt(0),
          action: function () {
            if (stack.length > 0) {
              a = stack.pop();
              output += String.fromCharCode(a);
            }
          },
          isKeyPressed: function (shift_pressed, key) {
            return false;
          },
        },

        // QUEUE: toggles reading the stack data as FIFO rather than LIFO

        // COMMENTS: toggles actioning instructions

        // READ INSTRUCTION : pops the top of the stack, and pushes the instruction at that index (xXY) to the stack

        // WRITE INSTRUCTION :
        // index          : top of stack (format 0xXY)
        // instruction_id : second in stack
        // writes instruction_id at index of tokens
      };

      current_state = state.EDIT;

      var tokens = [];
      for (let i = 0; i < boxY; i++) {
        for (let j = 0; j < boxX; j++) {
          tokens[i * boxY + j] = token.EMPTY;
        }
      }

      var offset_data = [];

      const addPixel = (x, y) => {
        var newX = (2 * x) / (consoleX * fontsizeX) - 1;
        var newY = -((2 * y) / (consoleY * fontsizeY) - 1);
        offset_data.push(newX, newY);
      };

      function initGL(canvas) {
        var gl_props = {};

        gl = canvas.getContext("webgl2", { antialias: false });

        /*====================== Init Shaders =======================*/

        var v = document.getElementById("vertex").firstChild.nodeValue;
        var f = document.getElementById("fragment").firstChild.nodeValue;

        var vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, v);
        gl.compileShader(vs);

        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, f);
        gl.compileShader(fs);

        gl_props.program = gl.createProgram();
        gl.attachShader(gl_props.program, vs);
        gl.attachShader(gl_props.program, fs);
        gl.linkProgram(gl_props.program);

        gl.useProgram(gl_props.program);

        var offset_attrib_loc = gl.getAttribLocation(
          gl_props.program,
          "offset"
        );
        var coordinates_loc = gl.getAttribLocation(
          gl_props.program,
          "coordinates"
        );

        /*========== Defining and storing the geometry =========*/

        var pixel_unit_x = 1 / (consoleX * fontsizeX);
        var pixel_unit_y = 1 / (consoleY * fontsizeY);

        var quad_vertices = new Float32Array([
          -pixel_unit_x,
          -pixel_unit_y,
          pixel_unit_x,
          -pixel_unit_y,
          -pixel_unit_x,
          pixel_unit_y,
          -pixel_unit_x,
          pixel_unit_y,
          pixel_unit_x,
          -pixel_unit_y,
          pixel_unit_x,
          pixel_unit_y,
        ]);

        var offset_array = new Float32Array(offset_data);

        gl_props.vertex_count = quad_vertices.length / 2;
        gl_props.instance_count = offset_data.length / 2;

        // Create and bind VAO
        gl_props.vao = gl.createVertexArray();
        gl.bindVertexArray(gl_props.vao);

        // Create and populate quad VBO
        var vbuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);
        gl.bufferData(gl.ARRAY_BUFFER, quad_vertices, gl.STATIC_DRAW);

        // Point coordinates attribute to quad VBO
        gl.enableVertexAttribArray(coordinates_loc);
        gl.vertexAttribPointer(coordinates_loc, 2, gl.FLOAT, false, 0, 0);

        // Create and populate instance VBO
        gl_props.instance_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gl_props.instance_buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(offset_data),
          gl.DYNAMIC_DRAW
        );

        // Point offsets attribute to instance VBO
        gl.enableVertexAttribArray(offset_attrib_loc);
        gl.vertexAttribPointer(offset_attrib_loc, 2, gl.FLOAT, false, 0, 0);
        gl.vertexAttribDivisor(offset_attrib_loc, 1);

        // Unbind buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        return { gl: gl, ...gl_props };
      }

      function drawGL(canvas, gl_props) {
        gl_props.instance_count = offset_data.length / 2;

        /*============= Clear canvas ================*/

        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Create and populate instance VBO
        gl.bindBuffer(gl.ARRAY_BUFFER, gl_props.instance_buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(offset_data),
          gl.DYNAMIC_DRAW
        );

        /*============= Drawing the Quads ================*/

        gl.useProgram(gl_props.program);
        gl.bindVertexArray(gl_props.vao);
        gl.drawArraysInstanced(
          gl.TRIANGLES,
          0,
          gl_props.vertex_count,
          gl_props.instance_count
        );
      }

      function mod(n, m) {
        return ((n % m) + m) % m;
      }

      direction = token.RIGHT;
      stack = [];

      function reset() {
        output = "";
        run = false;
        direction = token.RIGHT;
        stack = [];
        cursorX = 0;
        cursorY = 0;
        // document.getElementById("stack").innerHTML = "";
        // document.getElementById("output").innerHTML = "";
      }

      function updateStack() {
        s = "| ";
        for (let i = 0; i < stack.length; i++) {
          s += stack[i] + " | ";
        }
        // document.getElementById("stack").innerHTML = s;
      }

      function rotateClockwise() {
        if (direction == token.RIGHT) {
          direction = token.DOWN;
        } else if (direction == token.DOWN) {
          direction = token.LEFT;
        } else if (direction == token.LEFT) {
          direction = token.UP;
        } else if (direction == token.UP) {
          direction = token.RIGHT;
        }
      }

      function step() {
        tok = tokens[cursorY * boxY + cursorX];
        tok.action();
        updateStack();
        nextPosition();
      }

      function nextPosition() {
        switch (direction) {
          case token.RIGHT:
            cursorX += 1;
            break;
          case token.LEFT:
            cursorX -= 1;
            break;
          case token.UP:
            cursorY -= 1;
            break;
          case token.DOWN:
            cursorY += 1;
            break;
        }
        run =
          run &&
          cursorX > -1 &&
          cursorX < boxX &&
          cursorY > -1 &&
          cursorY < boxY;
      }

      setInterval(function () {
        if (run) {
          step();
        }
      }, 1);
      window.onload = function () {
        document.addEventListener("resize", function (event) {
          console.log("resize event");
        });
        var canvas = document.getElementById("myCanvas");

        canvas.width = consoleX * fontsizeX * scale;
        canvas.height = consoleY * fontsizeY * scale;

        const { gl, ...gl_props } = initGL(canvas);
        drawScreen(gl, gl_props, canvas);

        function logMessage(message) {
          console.log(message);
        }

        document.body.addEventListener("keydown", (e) => {
          if (current_state == state.EDIT) {
            if (e.key == "Shift") {
              shift = true;
            }
            if (e.key == "Control") {
              ctrl = true;
            }
            if (ctrl) {
              if (e.key == "c") {
                s = "";
                for (let i = 0; i < tokens.length; i++) {
                  s += tokens[i];
                }
                console.log(s);
              }
            }
            // if (shift) {
            //     if (e.key == "ArrowLeft") {
            //         tokens[cursorY*boxY+cursorX] = token.LEFT;
            //     }
            //     else if (e.key == "ArrowRight") {
            //         tokens[cursorY*boxY+cursorX] = token.RIGHT;
            //     }
            //     else if (e.key == "ArrowUp") {
            //         tokens[cursorY*boxY+cursorX] = token.UP;
            //     }
            //     else if (e.key == "ArrowDown") {
            //         tokens[cursorY*boxY+cursorX] = token.DOWN;
            //     }
            //     else if (e.key == "D") {
            //         tokens[cursorY*boxY+cursorX] = token.CLONE_TOP;
            //     }
            // }

            for (const tok in token) {
              console.log(tok);
              if (tok.isKeyPressed(shift, e.key)) {
                tokens[cursorY * boxY + cursorX] = tok;
              }
            }

            if (e.key == "ArrowLeft") {
              cursorX = mod(cursorX - 1, boxX);
            } else if (e.key == "ArrowRight") {
              cursorX = mod(cursorX + 1, boxX);
            } else if (e.key == "ArrowUp") {
              cursorY = mod(cursorY - 1, boxY);
            } else if (e.key == "ArrowDown") {
              cursorY = mod(cursorY + 1, boxY);
            }
            switch (e.key) {
              case " ":
                tokens[cursorY * boxY + cursorX] = token.EMPTY;
                break;
              case "Delete":
                tokens[cursorY * boxY + cursorX] = token.EMPTY;
                break;
              case "Backspace":
                tokens[cursorY * boxY + cursorX] = token.EMPTY;
                break;
              case "0":
                tokens[cursorY * boxY + cursorX] = token.ZERO;
                break;
              case "1":
                tokens[cursorY * boxY + cursorX] = token.ONE;
                break;
              case "2":
                tokens[cursorY * boxY + cursorX] = token.TWO;
                break;
              case "3":
                tokens[cursorY * boxY + cursorX] = token.THREE;
                break;
              case "4":
                tokens[cursorY * boxY + cursorX] = token.FOUR;
                break;
              case "5":
                tokens[cursorY * boxY + cursorX] = token.FIVE;
                break;
              case "6":
                tokens[cursorY * boxY + cursorX] = token.SIX;
                break;
              case "7":
                tokens[cursorY * boxY + cursorX] = token.SEVEN;
                break;
              case "8":
                tokens[cursorY * boxY + cursorX] = token.EIGHT;
                break;
              case "9":
                tokens[cursorY * boxY + cursorX] = token.NINE;
                break;
              case "A":
                tokens[cursorY * boxY + cursorX] = token.A;
                break;
              case "B":
                tokens[cursorY * boxY + cursorX] = token.B;
                break;
              case "C":
                tokens[cursorY * boxY + cursorX] = token.C;
                break;
              case "D":
                tokens[cursorY * boxY + cursorX] = token.D;
                break;
              case "E":
                tokens[cursorY * boxY + cursorX] = token.E;
                break;
              case "F":
                tokens[cursorY * boxY + cursorX] = token.F;
                break;
              case "a":
                tokens[cursorY * boxY + cursorX] = token.A;
                break;
              case "b":
                tokens[cursorY * boxY + cursorX] = token.B;
                break;
              case "c":
                tokens[cursorY * boxY + cursorX] = token.C;
                break;
              case "d":
                tokens[cursorY * boxY + cursorX] = token.D;
                break;
              case "e":
                tokens[cursorY * boxY + cursorX] = token.E;
                break;
              case "f":
                tokens[cursorY * boxY + cursorX] = token.F;
                break;
              case "*":
                tokens[cursorY * boxY + cursorX] = token.MUL;
                break;
              case "/":
                tokens[cursorY * boxY + cursorX] = token.DIV;
                break;
              case "%":
                tokens[cursorY * boxY + cursorX] = token.MOD;
                break;
              case "+":
                tokens[cursorY * boxY + cursorX] = token.ADD;
                break;
              case "-":
                tokens[cursorY * boxY + cursorX] = token.SUB;
                break;
              case "_":
                tokens[cursorY * boxY + cursorX] = token.EMPTY_STACK;
                break;
              case "?":
                tokens[cursorY * boxY + cursorX] = token.ZERO_TEST;
                break;
              case "^":
                tokens[cursorY * boxY + cursorX] = token.POP;
                break;
              case "p":
                tokens[cursorY * boxY + cursorX] = token.PRINT_CHAR;
                break;
              case "P":
                tokens[cursorY * boxY + cursorX] = token.PRINT_CHAR;
                break;
            }
            drawScreen(gl, c);
          } else if (current_state == state.RUN) {
            switch (e.key) {
              case " ":
                console.log("step.");
                step();
                drawScreen(gl, c);
                break;
              case "Enter":
                console.log("step.");
                run = !run;
                drawScreen(gl, c);
                break;
              case "r":
                reset();
                drawScreen(gl, c);
                break;
            }
          }
          if (e.key == "Tab") {
            e.preventDefault();
            if (current_state == state.EDIT) {
              current_state = state.RUN;
              reset();
            } else if (current_state == state.RUN) {
              current_state = state.EDIT;
              reset();
            }
            drawScreen(gl, c);
          }

          logMessage(`Key "${e.key}" pressed  [event: keydown]`);
        });

        document.body.addEventListener("keyup", (e) => {
          if (e.key == "Shift") {
            shift = false;
          }
          // drawbox();
          logMessage(`Key "${e.key}" released  [event: keyup]`);
        });
      };

      function drawChar(
        textPosX,
        textPosY,
        char_index,
        options = {
          inverted: false,
          pixelOffsetX: 0,
          pixelOffsetY: 0,
        }
      ) {
        const { inverted, pixelOffsetX = 0, pixelOffsetY = 0 } = options;
        const character = cp437[char_index];
        const expectedValue = inverted ? 0 : 1;
        for (var y = 0; y < fontsizeY; y++) {
          for (var x = 0; x < fontsizeX; x++) {
            if (character[x + y * fontsizeY] === expectedValue) {
              var posX = textPosX * fontsizeX + x + pixelOffsetX;
              var posY = textPosY * fontsizeY + y + pixelOffsetY;
              addPixel(posX, posY);
            }
          }
        }
      }

      function drawText(
        textPosX,
        textPosY,
        text,
        color = "white",
        highlight = "black"
      ) {
        for (var i = 0; i < text.length; i++) {
          drawChar(textPosX + i, textPosY, text.charCodeAt(i), {
            pixelOffsetX: -i * 2,
            inverted: highlight === "white",
          });
        }
      }

      function drawParagraph(
        textPosX,
        textPosY,
        text,
        color = "white",
        highlight = "black"
      ) {
        var lines = text.split("\n");
        for (var j = 0; j < lines.length; j++) {
          var line = lines[j];
          for (var i = 0; i < line.length; i++) {
            drawChar(textPosX + i, textPosY + j, line.charCodeAt(i), {
              pixelOffsetX: -i * 2,
              inverted: highlight === "white",
            });
          }
        }
      }

      function drawBoxSingle(minX, minY, maxX, maxY) {
        for (var i = minX + 1; i < maxX; i++) {
          drawChar(i, minY, 196); // ─
          drawChar(i, maxY, 196); // ─
        }
        for (var i = minY + 1; i < maxY; i++) {
          drawChar(minX, i, 179); // │
          drawChar(maxX, i, 179); // │
        }
        drawChar(minX, minY, 218); // ┌
        drawChar(maxX, minY, 191); // ┐
        drawChar(minX, maxY, 192); // └
        drawChar(maxX, maxY, 217); // ┘
      }

      function drawBoxDouble(minX, minY, maxX, maxY) {
        for (var i = minX + 1; i < maxX; i++) {
          drawChar(i, minY, 205); // ═
          drawChar(i, maxY, 205); // ═
        }
        for (var i = minY + 1; i < maxY; i++) {
          drawChar(minX, i, 186); // ║
          drawChar(maxX, i, 186); // ║
        }
        drawChar(minX, minY, 201); // ╔
        drawChar(maxX, minY, 187); // ╗
        drawChar(minX, maxY, 200); // ╚
        drawChar(maxX, maxY, 188); // ╝
      }

      function drawBoxHorizontalDivide(y, minX, maxX) {
        for (var i = minX + 1; i < maxX; i++) {
          drawChar(i, y, 196); // ─
          drawChar(i, y, 196); // ─
        }
        drawChar(minX, y, 195); //
        drawChar(maxX, y, 180); //
      }

      function drawBoxVerticalDivide(x, minY, maxY) {
        for (var i = minY + 1; i < maxY; i++) {
          drawChar(x, i, 179); // │
          drawChar(x, i, 179); // │
        }
        drawChar(x, minY, 209); //
        drawChar(x, maxY, 207); //
      }

      function drawBox() {
        drawBoxSingle(2, 2, 19, 19);
        for (var i = 0; i < 16; i++) {
          for (var j = 0; j < 16; j++) {
            // var rand = Math.floor(Math.random() * 256);
            if (cursorX == i && cursorY == j) {
              drawChar(3 + i, 3 + j, tokens[i + j * boxX].ascii, {
                inverted: true,
              });
            } else {
              drawChar(3 + i, 3 + j, tokens[i + j * boxX].ascii);
            }
          }
        }
      }

      function drawStack() {
        for (var i = 0; i < stack.length; i++) {
          hex = stack[i].toString(16).toUpperCase();
          if (hex.length == 1) {
            hex = "0" + hex;
          }
          drawText(22, 3 + i, " x" + hex);
        }
      }

      function drawScreen(gl, gl_props, canvas) {
        if (current_state == state.EDIT) {
          drawEditScreen(canvas);
        } else if (current_state == state.RUN) {
          drawRunScreen(canvas);
        }
        drawGL(canvas, gl_props);
      }

      function drawEditScreen(canvas) {
        drawBoxDouble(0, 0, consoleX - 1, consoleY - 1);
        drawBoxVerticalDivide(21, 0, consoleY - 1);
        drawBox();
        drawText(2, 21, "DIR:");
        drawChar(6, 21, direction.ascii);
        drawText(3, 2, "EDIT", (color = "white"));
        drawText(2, 23, "TAB:  Run Mode", (color = "gray"));
        for (var i = 0; i < consoleX; i++) {
          drawText(i, 0, " ", (color = "white"), (highlight = "white"));
          drawText(
            i,
            consoleY - 1,
            " ",
            (color = "white"),
            (highlight = "white")
          );
        }
        drawText(
          1,
          0,
          "C:\\\\STOOP.exe > PROBLEM 2",
          (color = "black"),
          (highlight = "white")
        );

        // var s = "Problem 2 - The Stack\n" +
        //     "\n" +
        //     "A STOOP program has a pointer which moves in a given\n" +
        //     "direction, manipulating the stack as it evaluates\n" +
        //     "the square.\n" +
        //     "\n" +
        //     "Write a program that takes numbers (0-9) from the\n" +
        //     "stack and prints the associated ASCII number.\n" +
        //     "\n" +
        //     "You may find the following commands helpful:\n" +
        //     "\n" +
        //     "+: Pops the top two elements from the stack, computes\n" +
        //     "   the sum, and places the result on the stack\n" +
        //     "\n" +
        //     "*: Pops the top two elements from the stack, computes\n" +
        //     "   the product, and places the result on the stack\n" +
        //     "\n" +
        //     "p: Pops the top of the stack and prints the\n" +
        //     "   associated ASCII number\n" +
        //     "\n" +
        //     "_: Checks if the stack is empty. If so, the pointer\n" +
        //     "   is rotated clockwise. Otherwise, nothing happens\n"
        var s =
          String.fromCharCode(24) +
          String.fromCharCode(25) +
          String.fromCharCode(26) +
          String.fromCharCode(27) +
          " : Changes the pointer to move in the direction the \n" +
          "       arrow is pointing (Shift + Arrow Key)\n" +
          "\n" +
          "0-F  : Adds hex number to the top of the stack\n" +
          "\n" +
          "+*   : Pops the top two elements from the stack, computes\n" +
          "       the sum/product, and places the result on the stack\n" +
          "\n" +
          "-/%  : Pops the top two elements from the stack, computes\n" +
          "       the subtraction/division/modulus, and places the \n" +
          "       result on the stack. NOTE: The top of the stack is \n" +
          "       the numerator\n" +
          "\n" +
          "p    : Pops the top of the stack and prints the\n" +
          "       associated ASCII number\n" +
          "\n" +
          // String.fromCharCode(174) + String.fromCharCode(175) +
          // "   : Pops the top of the stack and prints the\n" +
          // "       associated ASCII number\n" +
          // "\n" +
          "_    : Checks if the stack is empty. If so, the pointer\n" +
          "       is rotated clockwise. Otherwise, nothing happens\n" +
          "\n" +
          "?    : Checks if the top of the stack is zero. If so, \n" +
          "       the pointer is rotated clockwise. Otherwise,\n" +
          "       nothing happens\n" +
          "\n" +
          String.fromCharCode(127) +
          "    : Duplicates the top of the stack (Shift + D)\n" +
          "\n" +
          "^    : Pops the top of the stack\n" +
          "\n";
        drawText(
          33,
          2,
          " INSTRUCTION REFERENCE (1/1) ",
          (color = "black"),
          (highlight = "white")
        );

        drawParagraph(24, 4, s);

        drawText(
          36,
          37,
          " PAGE UP / PAGE DOWN ",
          (color = "black"),
          (highlight = "white")
        );
      }

      function drawRunScreen(canvas) {
        drawBoxDouble(0, 0, consoleX - 1, consoleY - 1);
        drawText(22, 1, "stack");
        drawBoxHorizontalDivide(gl, 2, 21, 26);
        drawStack();
        drawBoxVerticalDivide(21, 0, consoleY - 1);
        drawBoxVerticalDivide(26, 0, consoleY - 1);
        drawBox();
        drawText(2, 21, "DIR:");
        drawChar(6, 21, direction.ascii);
        drawText(2, 23, "TAB:  Edit Mode", (color = "gray"));
        // drawText(gl, 2, 24, "ENTER:Run/Stop", color='gray');
        drawText(2, 24, "SPACE:Step", (color = "gray"));
        drawText(2, 25, "R:    Reset", (color = "gray"));
        drawText(3, 2, "RUN", (color = "white"));
        for (var i = 0; i < consoleX; i++) {
          drawText(i, 0, " ", (color = "white"), (highlight = "white"));
          drawText(
            i,
            consoleY - 1,
            " ",
            (color = "white"),
            (highlight = "white")
          );
        }
        drawText(
          1,
          0,
          "C:\\\\STOOP.exe > PROBLEM 2",
          (color = "black"),
          (highlight = "white")
        );
        drawText(44, 2, " CONSOLE ", (color = "black"), (highlight = "white"));
        drawText(28, 3, ">");
        drawText(29, 3, output);
      }
    </script>
    <style>
      body {
        background-color: black;
      }

      canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        margin-right: -50%;
        transform: translate(-50%, -50%);
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
  </body>
</html>
